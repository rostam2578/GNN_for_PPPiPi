# graph building with the detailed Realistic neighbors
print('\n\n\n\n', 'The graph ...', '\n\n')

import dgl
import numpy as np
#import pandas as pd
#import math
#from numpy import cumsum   
import torch
import matplotlib.pyplot as plt
#import networkx as nx
#from torch_geometric.data import Data
device = torch.device('cuda')
import datetime
t = datetime.datetime.now()

#########################################################
# import the edges generated by FirstNeighbors.py
edge_index1st = np.load('/hpcfs/bes/mlgpu/hoseinkk/MLTracking/bhabha/GNN/MDCwiresfirstneighbors/share/edge_index.npy')

# import second neighbors generated by SecondNeighbors.py
edge_index2nd = np.load('/hpcfs/bes/mlgpu/hoseinkk/MLTracking/bhabha/GNN/MDCwiresfirstneighbors/share/secondneighbors.npy')

edge_index = np.concatenate((edge_index1st, edge_index2nd), axis=0)
edge_index = torch.tensor(edge_index, dtype=torch.long).t().contiguous()
print('\nedge_index\n', edge_index, '\n\nedge_index shape\n', edge_index.shape)

# Defining MDC graph with dgl for "MDCwiresfirstneighbors"
dglgraph = dgl.graph((edge_index[0], edge_index[1])).to(device)#, num_nodes=6795)
print('graph:', dglgraph, '\nnodes:', dglgraph.nodes(), '\nnodes shape:', dglgraph.nodes().shape, '\nedges:', dglgraph.edges())

# add a reverse edge for each edge in the original graph with 
dglgraph = dgl.add_reverse_edges(dglgraph)
# add self loop
#dglgraph.add_self_loop(dglgraph, fill_data='max')

# Assign a 1-dimensional node feature vector for each node.
dglgraph.ndata['nfet'] = torch.randn((6796, 1), requires_grad=True, device=device)
# Assign a 1-dimensional edge feature vector for each edge.
dglgraph.edata['efet'] = torch.ones((1175277 * 2, 1), requires_grad=True, device=device)

#weighttensor = torch.ones((36593 * 2, 1), requires_grad=True, device=device)

#########################################################
# some info of the graph.
print("\nnumber of nodes:", dglgraph.num_nodes())
print("\nnumber of edges:", dglgraph.num_edges())
print("\nnode features (random input):", dglgraph.ndata['nfet'], '\nnode features sum:', dglgraph.ndata['nfet'].sum())
print("\nedges features:", dglgraph.edata['efet'], "\nedges features sum:", dglgraph.edata['efet'].sum())
#print('\nweight tensor', weighttensor)
infnod = 234
print(f"\nexample: \nOut degrees of node {infnod}:", dglgraph.out_degrees(infnod))
print(f"\nIn degrees of node {infnod}:", dglgraph.in_degrees(infnod))

# save a graph 
#dgl.save_graphs 

# load a graph
#dgl.load_graphs